代理模式
    定义：
        代理模式 给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。（中介）

  为什么使用代理模式

    中介隔离：
               有些时候，客户类 不想或不能 直接引用一个委托对象
               而 代理类对象可以在 客户类 + 委托对象 间起到中介作用

           特征：代理类和委托类实现相同接口

    开闭原则，增加功能：
        除了中介之外，还可以通过 给代理类增加额外的功能 拓展委托类功能（自如）
            这样秩序修改代理类 而不需要修改委托类  符合开闭原则


        代理类  主要负责：
                    委托预处理消息
                    过滤消息
                    把消息转发给委托类
                    事后 对返回结果的处理

              代理类本身不真正实现服务，通过调用委托类的相关方法，提供特定服务

        真正的服务功能还是需要委托类来实现，但是可以在业务功能前后 加入公告服务

        例如：项目加入缓存，日志，可以使用代理类完成

  两种代理模式（按照代理创建的时期分类）
        静态代理
                对其编译，程序运行之前，代理类.class文件已经被创建

            优点：可以做到在符合开闭原则的情况下对目标对象进行功能拓展
            缺点：为每一个服务都得创建代理类，工作量大。同时接口一旦改变。代理类也要改变


        动态代理
             程序在运行是通过 反射机制 动态创建

            注意Proxy.newProxyInstance()方法接受三个参数：

            ClassLoader loader:指定当前目标对象使用的类加载器,获取加载器的方法是固定的
            Class<?>[] interfaces:指定目标对象实现的接口的类型,使用泛型方式确认类型
            InvocationHandler:指定动态处理器，执行目标对象的方法时,会触发事件处理器的方法

              仅支持interface代理  共同父类Proxy，无法对class进行动态代理


        CGLIB代理
            JDK实现动态代理需要实现类通过接口定义业务方法，对于没有接口的类，
            如何实现动态代理呢，这就需要CGLib了。CGLib采用了非常底层的字节码技术，
            其原理是通过字节码技术为一个类创建子类，
            并在子类中采用方法拦截的技术拦截所有父类方法的调用，
            顺势织入横切逻辑。但因为采用的是继承，所以不能对final修饰的类进行代理。
            JDK动态代理与CGLib动态代理均是实现Spring AOP的基础。
